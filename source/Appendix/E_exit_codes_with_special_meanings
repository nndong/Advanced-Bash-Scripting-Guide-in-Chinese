附录E. 有特殊意义的退出码

表格E-1. 退出状态码
｜退出状态码编号｜含义｜例子｜注解｜
｜1｜指所有的错误｜let "var1 = 1/0" | 包含各种各样的错误，比如“除以0”和其它不允许的操作｜
｜2｜对shell内建指令的错误使用（基于Bash文档）｜empty_function() {} ｜缺少关键字或者命令，或者权限问题（使用diff来比较二进制文件失败时的返回码）｜
｜126｜调用的命令无法执行｜/dev/null | 权限问题或者命令无法执行 ｜
｜127｜“找不到命令”｜illegal_command ｜ 有可能是$PATH的问题或者错别字 ｜
｜128｜退出时参数错误｜exit 3.14159｜exit命令只需要一个在0-255之间的正整数做参数（请参考第一条脚注）｜
｜128+n｜“n”有致命错误｜kill -9 $PPID ｜	$? 返回 137 (128 + 9)｜
｜130｜脚本被Control-C终止｜Ctl-C｜Control-C的错误编码是2,(130=128+2,参考上面一条)｜
｜255*｜退出状态超出范围｜exit －1｜exit命令需要一个在0-255之间的正整数做参数｜

基于上述表格，退出状态码1 - 2, 126 - 165, and 255[1] 有特殊意义，因此用户应该避免指定它们作为退出时的参数值。用exit 127
来终止脚本会导致在调试时混乱（退出状态码应该是“找不到命令”呢还是一个用户指定的值呢？）。然而很多脚本使用exit 1作为通用的错误退出码。
因为退出状态码1指代了很多可能的错误，因此在调试中它不是特别有效。

一直以来大家都尝试着把退出状态码的值系统化（请看/usr/include/sysexits.h）, 然而C和C++程序员也在计划此事。一个类似适用于脚本
的标准可能也是合适的。为了遵循C／C++标准，本书作者建议把用户自定义的退出码限制在64-113范围内（还要再加上0，它是成功执行的状态码）。
这会分配50个合理的状态码，并且使得调试脚本的过程更加直接。［2］除了覆盖已存在的系统变量的例子，如例 9-2，所有本书相关示例中的用户
自定义的状态码都遵循这一标准。

shell脚本执行退出后，只有在Bash或者有sh提示符的命令行中敲入$?得到的结果才和上述表格是一致的。

提示：
［1］超出范围的退出值会导致无法预期的退出状态码。大于255的退出值会返回对256做模计算后的状态码。例如，exit 3809得到的退出状态码
是225（3809%256=225）
［2］更新文件/usr/include/sysexits.h来分配之前没有用过的从64到78作为退出状态码。预计这些没有被分配的退出状态码在未来会被限制使用。
本书的作者不会修正脚本示例来和变化后的标准保持一致。这不会引起任何问题的，因为编译后的C／C++二进制文件和shell脚本使用的退出状态码没有
交集或者冲突。
